# Decidibilità \hfill \faFlask








Questo capitolo servirà a dare alcuni esempi di linguaggi Turing-decidibili; si renderanno utili le precedenti pagine riguardo gli automi finiti e soprattutto le definizioni di linguaggi T-riconoscibili e T-decidibili.

I problemi computazionali proposti, a partire da quello dell'*accettazione* qua sotto, verranno rappresentati mediante linguaggi; si tratterà quindi di scrivere il problema in questione come un insieme di stringhe e chiedersi se esiste una MdT che decide tale linguaggio[^12]. Mostrare dunque che il linguaggio è decidibile equivale a mostrare che il problema computazionale è decidibile.

\begin{theorem}
Sia $A_{DFA}$ il linguaggio contenente le coppie formate dalle codifiche di tutti i DFA con delle particolari stringhe che essi accettano
\begin{equation*}
A_{DFA} = \{\langle B,w\rangle\ |\ \text{$B$ è un DFA che accetta la stringa di input $w$}\}
\end{equation*}
$A_{DFA}$ è un linguaggio decidibile.
\begin{proof}
L'idea è quella di presentare una MdT $M$ che decide $A_{DFA}$. $M$ deve prendere come input la coppia $\langle B,w\rangle$, simulare $B$ su $w$ e accettare se la simulazione termina in uno stato di accettazione, viceversa rifiutare.

Quindi, dopo aver controllato la validità della coppia in input, $M$ esegue la simulazione: tiene traccia dello stato corrente di $B$ e della sua posizione corrente nell'input $w$ scrivendo queste informazioni sul nastro, usa la funzione di transizione per aggiornare stati e posizioni fin quando non termina l'elaborazione dell'ultimo simbolo di $w$. $M$ accetta l'input se $B$ si trova in uno stato di accettazione, rifiuta altrimenti.
\end{proof}
\end{theorem}

\begin{theorem}
Sia $A_{NFA}$ il linguaggio contenente le coppie formate dalle codifiche di tutti gli NFA con delle particolari stringhe che essi accettano
\begin{equation*}
A_{NFA} = \{\langle B,w\rangle\ |\ \text{$B$ è un NFA che accetta la stringa di input $w$}\}
\end{equation*}
$A_{NFA}$ è un linguaggio decidibile.
\begin{proof}
Presentiamo una MdT $N$ che decide $A_{NFA}$. $N$ converte l'NFA $B$ in un DFA $C$ equivalente, esegue $M$ come una sottoprocedura che decide $A_{DFA}$ su input $\langle C,w\rangle$ e accetta se $M$ accetta, altrimenti rifiuta.
\end{proof}
\end{theorem}

* * *

Con prossimo problema, chiamato *test del vuoto* per il linguaggio di un automa finito, si vuove determinare se un DFA accetta una qualche stringa.

\begin{theorem}
Sia $E_{DFA}$ il linguaggio contenente le codifiche di tutti i DFA che non accettano alcuna stringa
\begin{equation*}
E_{DFA} = \{\langle A\rangle\ |\ \text{$A$ è un DFA e $L(A){=}\emptyset$}\}
\end{equation*}
$E_{DFA}$ è un linguaggio decidibile.
\begin{proof}
Ciascun DFA accetta almeno una stringa sse dallo stato iniziale è possibile raggiungere uno stato di accettazione percorrendo il verso delle freccie; posso quindi trattare i DFA come grafi connessi orientati e progettare una MdT $T$ che esegua la marcatura degli stati per implementare tale controllo.

$T$ marca lo stato iniziale e, successivamente, marca tutti gli stati che hanno una transizione proveniente da uno stato già marcato finchè non si esauriscono gli stati inesplorati. Se nessuno stato di accettazione è marcato accetta, altrimenti rifiuta.
\end{proof}
\end{theorem}

\begin{theorem}
Sia $EQ_{DFA}$ il linguaggio contenente tutte le coppie formate dalle codifiche di due DFA che riconoscono lo stesso linguaggio
\begin{equation*}
EQ_{DFA} = \{\langle A,B\rangle\, |\, \text{$A$ e $B$ sono DFA tali che $L(A){=}L(B)$}\}
\end{equation*}
$EQ_{DFA}$ è un linguaggio decidibile.
\begin{proof}
A partire da $A$ e $B$ costriusco un nuovo DFS $C$ che accetta solo quella stringhe che sono accettate da $A$ o da $B$ ma non da entrambi. In particolare, se $A$ e $B$ riconoscono lo stesso linguaggio, $C$ non accetterà nulla
\begin{equation*}
L(C) = \big( L(A) \cap \overline{L(B)} \big) \cup \big( \overline{L(A)} \cap L(B) \big)
\end{equation*}
Quindi $L(C){=}\emptyset \Leftrightarrow L(A){=}L(B)$.
\end{proof}
\end{theorem}








[^12]: Nella formalizzazione del linguaggio salta subito all'occhio che automi e MdT sono rappresentati come stringhe. Per fare questo è necessaria una corrispondenza biunivoca tra macchina e codifica della macchina di cui non ho ancora fatto menzione (sarà argomento dei prossimi capitoli). Per adesso è sufficiente sapere che ogni macchina può essere codificata con una stringa e viceversa.

