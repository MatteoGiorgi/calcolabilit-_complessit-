# Automi e linguaggi \hfill \faCubes




## DFA e NFA

In questo capitolo verranno richiamate alcune nozioni utili per studiare *decidibilità*, *riducibilità* ed eventualmente l'insolubilità di problemi. Sarà utile avere ben chiaro cosa siano automi, linguaggi regolari e la loro relazione con le MdT.

\begin{definition}
Un \underline{automa finito determinastico} (DFA) è la quintupla
$$(Q, \Sigma, \delta, q_0, F)$$

\begin{itemize}[itemsep=-7pt]
\item $Q$ è l'insieme finito degli stati
\item $\Sigma$ è l'insieme finito dei simboli (alfabeto)
\item $\delta{:}Q{\times}\Sigma{\rightarrow}Q$ è la funzione di transizione
\item $q_0{\in}Q$ è lo stato iniziale
\item $F{\subseteq}Q$ è l'insieme degli stati di accettazione
\end{itemize}
\end{definition}

La funzione di transizione $\delta$ definisce le regole per il cambiamento di stato: specifica esattamente uno stato successivo per ogni possibile combinazione di stato e simbolo in input. Se ne deduce che, *da ogni stato esce esattamente un arco di transizione per ogni possibile simbolo di input* (ecco perchè automa determinastico o DFA).

\begin{definition}
Un \underline{automa finito non deterministico} (NFA) è la quintupla
$$(Q, \Sigma, \Delta, q_0, F)$$

\begin{itemize}[itemsep=-7pt]
\item $Q$ è l'insieme finito degli stati
\item $\Sigma$ è l'insieme finito dei simboli (alfabeto)
\item $\Delta{:}Q{\times}\Sigma_\epsilon{\rightarrow}\mathcal{P}(Q)$ è la funzione di transizione
\item $q_0{\in}Q$ è lo stato iniziale
\item $F{\subseteq}Q$ è l'insieme degli stati di accettazione
\end{itemize}
\end{definition}

Le due definizioni di automa differiscono nel tipo[^7] della funzione di transizione. $\Delta$ prende uno stato dall'insieme degli stati $Q$, un simbolo dall'alfabeto $\Sigma_\epsilon{=}\Sigma{+}\{\epsilon\}$ e produce l'insieme dei possibili stati successivi (${\subseteq}\mathcal{P}(Q)$); $\delta$ invece, prende in input la coppia stato attuale, simbolo letto e produce un singolo stato successivo[^8].




## Linguaggio della macchina[^9]

Automa o MdT, incomincia a essere chiaro che la nostra macchina sia qualcosa che mangia stringhe e decide se appartengono a un dato insieme. Che succede allora quando una macchina prende un input? Esistono stringhe che la macchina non digerisce? Gli insiemi di stringhe che la macchina computa con successo hanno qualche proprietà particolare?

Per rispondere devo prima piazzare qualche paletto e senza perdere tempo in pesanti formalismi, ecco qua sotto alcune definizioni fondamentali.

\begin{definition}
Sia $M{=}\{Q,\Sigma,\delta,q_0,F\}$ un automa finito e $w{=}w_0w_1...w_n$ una stringa composta da caratteri $w_i{\in}\Sigma$. Si dice che la macchina $M$ \underline{accetta la stringa} $w$ se esiste una sequenza di stati $[r_0,r_1,...,r_{n+1}]$ in $Q$, con tre condizioni

\begin{enumerate}[itemsep=-7pt]
\item $r_0{=}q_0$: la macchina è partita e si trova in $q_0$
\item $\delta(r_i,w_{i+1}){=}r_{i+1}$, $0{\leq}i{\leq}n{-}1$: la macchina cambia stato con $\delta$
\item $r_n{\in}F$: la macchina accetta l'input se termina in un $q_F{\in}F$
\end{enumerate}
\end{definition}

\begin{definition}
Il \underline{linguaggio della macchina} $M$ è l'insieme $A$ di tutte le stringhe accettate dalla macchina: $A{=}L(M)$.
\end{definition}

\begin{definition}
La macchina $M$ \underline{riconosce il linguaggio} $A$ se $A {=} \{w\, |\, w{\in}A,\, M \text{accetta}\, w\}$.
\end{definition}

\begin{definition}
Un linguaggio è chiamato \underline{regolare} sse esiste un automa finito che lo riconosce.
\end{definition}

Dalle precedenti proposizioni, sono già facilmente intuibili le seguenti implicazioni, che non dimostrerò per mancanza di spazio \faMehO.
$$\boxed{A\ \text{è regolare}} \Leftrightarrow \boxed{\exists\ M\ \text{che riconosce}\ A} \Leftrightarrow \boxed{M\ \text{accetta tutte le stringhe di}\ A}$$

### Le operazioni regolari

Trattare i linguaggi regolari non è lo scopo di queste note ma, visto che li ho introdotti, è giusto spendere due parole su come manipolarne le stringhe.

[^7]: Inteso come *arrow type* e generato dal costruttore di tipo che giustappone i tipi primitivi di argomenti e risultato ottenendo il tipo composto della funzione (`fact :: Integer -> Integer`).
[^8]: Come nella più comune biliografia $\mathcal{P}$ indica l'insieme delle parti e $\epsilon$ la stringa vuota, anche se in questo caso è più corretto riferirsi al carattere nullo.
[^9]: Qui c'è effettivamente un abuso di notazione: con il termine *macchina* mi riferisco ad un automa perchè queste proprietà sono valide anche per una MdT.

