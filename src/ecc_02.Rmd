# Automi e linguaggi \hfill \faCubes




## DFA e NFA

In questo capitolo verranno richiamate alcune nozioni utili per studiare *decidibilità*, *riducibilità* ed eventualmente l'insolubilità di problemi. Sarà utile avere ben chiaro cosa siano automi, linguaggi regolari e la loro relazione con le MdT.

\begin{definition}
Un \underline{automa finito deterministico} (DFA) è la quintupla
$$(Q, \Sigma, \delta, q_0, F)$$

\begin{itemize}[itemsep=-7pt]
\item $Q$ è l'insieme finito degli stati
\item $\Sigma$ è l'insieme finito dei simboli (alfabeto)
\item $\delta{:}Q{\times}\Sigma{\rightarrow}Q$ è la funzione di transizione
\item $q_0{\in}Q$ è lo stato iniziale
\item $F{\subseteq}Q$ è l'insieme degli stati di accettazione
\end{itemize}
\end{definition}

La funzione di transizione $\delta$ definisce le regole per il cambiamento di stato: specifica esattamente uno stato successivo per ogni possibile combinazione di stato e simbolo in input. Se ne deduce che *da ogni stato esce esattamente un arco di transizione per ogni possibile simbolo di input* (ecco perchè automa determinastico o DFA).

\begin{definition}
Un \underline{automa finito non deterministico} (NFA) è la quintupla
$$(Q, \Sigma, \Delta, q_0, F)$$

\begin{itemize}[itemsep=-7pt]
\item $Q$ è l'insieme finito degli stati
\item $\Sigma$ è l'insieme finito dei simboli (alfabeto)
\item $\Delta{:}Q{\times}\Sigma_\epsilon{\rightarrow}\mathcal{P}(Q)$ è la funzione di transizione
\item $q_0{\in}Q$ è lo stato iniziale
\item $F{\subseteq}Q$ è l'insieme degli stati di accettazione
\end{itemize}
\end{definition}

Le due definizioni di automa differiscono nel tipo[^7] della funzione di transizione. $\Delta$ prende uno stato dall'insieme degli stati $Q$, un simbolo dall'alfabeto $\Sigma_\epsilon{=}\Sigma{+}\{\epsilon\}$ e produce l'insieme dei possibili stati successivi (${\subseteq}\mathcal{P}(Q)$); $\delta$ invece, prende in input la coppia stato attuale, simbolo letto e produce un singolo stato successivo[^8].




## Linguaggio della macchina[^9]

Automa o MdT, incomincia a essere chiaro che la nostra macchina sia qualcosa che mangia stringhe e decide se appartengono a un dato insieme.

* Esistono stringhe che una macchina $M$ non digerisce?
* Che succede quando una macchina $M$ prende in input una stringa $w$?
* Come distinguo gli insiemi di stringhe che la macchina elabora?

Per rispondere devo prima piazzare qualche paletto e senza perdere tempo in pesanti formalismi, ecco qua sotto alcune definizioni fondamentali.

\begin{definition}
Sia $M{=}\{Q,\Sigma,\delta,q_0,F\}$ un automa finito e $w{=}w_0w_1...w_n$ una stringa composta da caratteri $w_i{\in}\Sigma$. Si dice che la macchina $M$ \underline{accetta la stringa} $w$ se esiste una sequenza di stati $[r_0,r_1,...,r_{n+1}]$ in $Q$, con tre condizioni

\begin{enumerate}[itemsep=-7pt]
\item $r_0{=}q_0$ \hfill La macchina è partita
\item $\delta(r_i,w_{i+1}){=}r_{i+1}$, $0{\leq}i{\leq}n{-}1$ \hfill La macchina cambia stato con $\delta$
\item $r_n{\in}F$ \hfill La macchina accetta l'input
\end{enumerate}
\end{definition}

Si noti l'assonanza con la definizione di computazione: i tre passi precedenti sono infatti da considerarsi i tre stadi della computazione per un automa finito. La macchina accetta l'input (quindi parte), salta di stato in stato con una legge predefinita (funzione di transizione) e dopo un numero indefinito (ma finito) di salti, casca in uno degli stati di terminazione.

\begin{definition}
Il \underline{linguaggio} $A$ della macchina $M$ è l'insieme di tutte le stringhe accettate dalla macchina: $A{=}L(M)$.
\end{definition}

\begin{definition}
La macchina $M$ \underline{riconosce il linguaggio} $A$ se $A {=} \{w\, |\, w{\in}A,\, M \text{accetta}\, w\}$.
\end{definition}

\begin{definition}
Un linguaggio $A$ è chiamato \underline{regolare} sse esiste un automa finito $M$ che lo riconosce.
\end{definition}

Dalle precedenti definizioni, posso già facilmente intuire qualche semplice implicazione che però non dimostro per mancanza di spazio (prova per esercizio) \faMehO.
$$\boxed{A\ \text{è regolare}} \Leftrightarrow \boxed{\exists\ M\ \text{che riconosce}\ A} \Leftrightarrow \boxed{M\ \text{accetta tutte le stringhe di}\ A}$$

\begin{definition}
Due macchine $M_1$ e $M_2$ si dicono \underline{equivalenti}  se riconoscono lo stesso linguaggio $A{=}L(M_1){=}L(M_2)$.
\end{definition}

### Le operazioni regolari

Trattare i linguaggi regolari non è lo scopo di queste note ma, visto che li ho introdotti, è giusto spendere due parole su come manipolarne le stringhe.

\begin{definition}
Dati i linguaggi $A$ e $B$, sono definite \underline{operazioni regolari}

\begin{enumerate}[itemsep=-7pt]
\item $A{\cup}B{=}\{w\, |\, w{\in}A \vee  w{\in}B\}$ Unione
\item $A{\circ}B{=}\{wv\, |\, w{\in}A \wedge  v{\in}B\}$ Concatenazione
\item $A^*{=}\{w_0w_1...w_k\, |\, w_i{\in}A \wedge 0{\leq}i{\leq}k\}$ Star
\end{enumerate}
\end{definition}

L'unione fa esattamente quello che ci si aspetti faccia l'unione tra insiemi: raggruppa tutte le stringhe di $A$ e $B$; la concatenazione antepone una stringa di $A$ ad una di $B$ in tutti i modi possibili; star concatena un numero qualsiasi di stringhe di $A$.

In ultimo è possibile dimostrare che la classe dei linguaggi regolari è chiusa rispetto alle tre operazioni regolari (vedi Sipser cap1).

## Equivalenza tra DFA e NFA

Erroneamente si potrebbe pensare che gli NFA abbiano maggior potere computazionale dei DFA, e che quindi riconoscano più linguaggi; non è così perchè automi finiti deterministici e non deterministici riconoscono la stessa classe di linguaggi. Vediamo di formalizzare l'idea.

\begin{theorem}
Per ogni automa finito non deterministico, esiste un automa finito deterministico equivalente.
\begin{proof}
L'idea è quella di procedere per costruzione e trasformare l'automa non deterministico in uno deterministico con $2^k$ stati, pari cioè alla cardinalità di $\mathcal{P}(Q_\text{NFA})$. Ricorda infatti che, se chiamiamo $k$ la cardinalità di $Q_\text{NFA}$, il numero dei sottoinsiemi corrispondenti ad una delle possibilità che il nuovo automa deve ricordare è $2^k$.

Sia $N{=}(Q,\Sigma,\delta,q_0,F)$ l'NFA di partenza che riconosce un linguaggio $A$, voglio costruire un DFA $M{=}(Q\prime,\Sigma\prime,\delta\prime,q_0^\prime,F\prime)$ equivalente. Inizialmente considero il caso più semplice in cui $N$ non ha $\epsilon$-archi.

\begin{enumerate}[itemsep=-7pt]
\item Ogni stato di $M$ è un insieme di stati di $N$
$$Q\prime = \mathcal{P}(Q)$$

\item Se $R$ è uno stato di $M$, esso è anche un insieme di stati di $N$. Quando $M$ legge un simbolo $w$ nello stato $R$, ci mostra gli stati successivi a quelli in $R$ e, poichè da ogni stato si può andare in un insieme di stati, ne prendiamo l'unione
\begin{align*}
R{\in}Q,\, w{\in}\Sigma\, \Rightarrow\, \delta\prime(R,w) &= \{q{\in}Q\, |\, \exists\, r{\in}R.\, q{\in}\delta(r,w)\}\\
                                                          &= \bigcup_{r \in R}\delta(r,w)
\end{align*}

\item Lo stato iniziale di $M$ è quello corrispondente alla collezione che contiene solamente lo stato iniziale di $N$
$$q_0^\prime = q_0$$

\item $M$ accetta se $N$ è in uno stato accettante in quel momento
$$F\prime = \{R{\in}Q\prime\, |\, \text{$R$ contiene uno stato accettante di $N$}\}$$
\end{enumerate}

Adesso considero anche gli $\epsilon$-archi. Per ogni stato $R$ di $M$, definisco $E(R)$ come la collezione di stati che possono essere raggiunti dagli elementi di $R$ proseguendo solo con $\epsilon$-archi (includendo gli stessi elementi di $R$). Per $R{\subseteq}Q$, sarà
$$E(R) = \{q\, |\, \text{$q$ può essere raggiunto da $R$ attraverso $0$ o più $\epsilon$-archi}\}$$

Poi modifico $\delta\prime$ in modo che possa raggiungere tutti quegli stati esplorabili con $\epsilon$-archi dopo ogni passo. Sostituisco $\delta(r,w)$ con $E(\delta(r,w))$ e ottengo
$$\delta\prime(R,w) = \{q{\in}Q\, |\, \exists\, r{\in}R.\, q{\in}E(\delta(r,w))\}$$

In ultimo devo modificare lo stato iniziale di $M$ per potermi muovere inizialmente su tutti i possibili stati che possono essere raggiunti dallo stato inizile di $N$ attraverso gli $\epsilon$-archi. Per fare questo cambio $q_0^\prime$ in $E(q_0)$. Ho completato la costruzione di $M$.

Da notare che $M$ funziona correttamente perchè ad ogni passo della computazione, entra in uno stato che corrisponde al sottoinsieme di stati nei quali $N$ potrebbe trovarsi.
\end{proof}
\end{theorem}

\begin{corollary}
(Dimostra per esercizio \faMehO)
$$\boxed{\text{$\exists$ un NFA che riconosce $L$}} \Leftrightarrow \boxed{\text{$\exists$ un DFA che riconosce $L$}} \Leftrightarrow \boxed{\text{$L$ è regolare}}$$
\end{corollary}





[^7]: L'*arrow type* di una funzione è generato dal *type constructor* che giustappone i tipi primitivi di argomenti e risultato ottenendo il tipo composto della funzione (`f :: a -> b`).
[^8]: Come nella più comune bibliografia $\mathcal{P}$ indica l'insieme delle parti e $\epsilon$ la stringa vuota, anche se in questo caso è più corretto riferirsi al carattere nullo.
[^9]: Abuso di notazione: qui (ed in futuro) con il termine *macchina* mi riferisco ad un automa ma queste proprietà sono valide anche per una MdT.

