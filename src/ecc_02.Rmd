# Automi e linguaggi \hfill \faCubes




## DFA e NFA

In questo capitolo verranno richiamate alcune nozioni utili per studiare *decidibilità*, *riducibilità* ed eventualmente l'insolubilità di problemi. Sarà utile avere ben chiaro cosa siano automi, linguaggi regolari e la loro relazione con le MdT.

\begin{definition}
Un \underline{automa finito determinastico} (DFA) è la quintupla
$$(Q, \Sigma, \delta, q_0, F)$$

\begin{itemize}[itemsep=-7pt]
\item $Q$ è l'insieme finito degli stati
\item $\Sigma$ è l'insieme finito dei simboli (alfabeto)
\item $\delta{:}Q{\times}\Sigma{\rightarrow}Q$ è la funzione di transizione
\item $q_0{\in}Q$ è lo stato iniziale
\item $F{\subseteq}Q$ è l'insieme degli stati di accettazione
\end{itemize}
\end{definition}

La funzione di transizione $\delta$ definisce le regole per il cambiamento di stato: specifica esattamente uno stato successivo per ogni possibile combinazione di stato e simbolo in input. Se ne deduce che, *da ogni stato esce esattamente un arco di transizione per ogni possibile simbolo di input* (ecco perchè automa determinastico o DFA).

\begin{definition}
Un \underline{automa finito non deterministico} (NFA) è la quintupla
$$(Q, \Sigma, \Delta, q_0, F)$$

\begin{itemize}[itemsep=-7pt]
\item $Q$ è l'insieme finito degli stati
\item $\Sigma$ è l'insieme finito dei simboli (alfabeto)
\item $\Delta{:}Q{\times}\Sigma_\epsilon{\rightarrow}\mathcal{P}(Q)$ è la funzione di transizione
\item $q_0{\in}Q$ è lo stato iniziale
\item $F{\subseteq}Q$ è l'insieme degli stati di accettazione
\end{itemize}
\end{definition}

Le due definizioni di automa differiscono nel tipo[^7] della funzione di transizione. $\Delta$ prende uno stato dall'insieme degli stati $Q$, un simbolo dall'alfabeto $\Sigma_\epsilon{=}\Sigma{+}\{\epsilon\}$ e produce l'insieme dei possibili stati successivi (${\subseteq}\mathcal{P}(Q)$); $\delta$ invece, prende in input la coppia stato attuale, simbolo letto e produce un singolo stato successivo[^8].




## Linguaggio della macchina[^9]

Automa o MdT, incomincia a essere chiaro che la nostra macchina sia qualcosa che mangia stringhe e decide se appartengono a un dato insieme.

* Esistono stringhe che una macchina $M$ non digerisce?
* Che succede quando una macchina $M$ prende in input una stringa $w$?
* Come distinguo gli insiemi di stringhe che la macchina elabora?

Per rispondere devo prima piazzare qualche paletto e senza perdere tempo in pesanti formalismi, ecco qua sotto alcune definizioni fondamentali.

\begin{definition}
Sia $M{=}\{Q,\Sigma,\delta,q_0,F\}$ un automa finito e $w{=}w_0w_1...w_n$ una stringa composta da caratteri $w_i{\in}\Sigma$. Si dice che la macchina $M$ \underline{accetta la stringa} $w$ se esiste una sequenza di stati $[r_0,r_1,...,r_{n+1}]$ in $Q$, con tre condizioni

\begin{enumerate}[itemsep=-7pt]
\item $r_0{=}q_0$: la macchina è partita e si trova in $q_0$
\item $\delta(r_i,w_{i+1}){=}r_{i+1}$, $0{\leq}i{\leq}n{-}1$: la macchina cambia stato con $\delta$
\item $r_n{\in}F$: la macchina accetta l'input se termina in un $q_F{\in}F$
\end{enumerate}
\end{definition}

Si noti l'assonanza con la definizione di computazione: i tre passi precedenti sono infatti da considerarsi i tre stadi della computazione per un automa finito. La macchina accetta l'input (quindi parte), salta di stato in stato con una legge predefinita (funzione di transizione) e dopo un numero indefinito (ma finito) di salti, casca in uno degli stati di terminazione.

\begin{definition}
Il \underline{linguaggio} $A$ della macchina $M$ è l'insieme di tutte le stringhe accettate dalla macchina: $A{=}L(M)$.
\end{definition}

\begin{definition}
La macchina $M$ \underline{riconosce il linguaggio} $A$ se $A {=} \{w\, |\, w{\in}A,\, M \text{accetta}\, w\}$.
\end{definition}

\begin{definition}
Un linguaggio $A$ è chiamato \underline{regolare} sse esiste un automa finito $M$ che lo riconosce.
\end{definition}

Dalle precedenti definizioni, posso già facilmente intuire qualche semplice implicazione che però non dimostro per mancanza di spazio (prova per esercizio) \faMehO.
$$\boxed{A\ \text{è regolare}} \Leftrightarrow \boxed{\exists\ M\ \text{che riconosce}\ A} \Leftrightarrow \boxed{M\ \text{accetta tutte le stringhe di}\ A}$$

\begin{definition}
Due macchine $M_1$ e $M_2$ si dicono \underline{equivalenti}  se riconoscono lo stesso linguaggio $A{=}L(M_1){=}L(M_2)$.
\end{definition}

### Le operazioni regolari[^10]

Trattare i linguaggi regolari non è lo scopo di queste note ma, visto che li ho introdotti, è giusto spendere due parole su come manipolarne le stringhe.

\begin{definition}
Dati i linguaggi $A$ e $B$, sono definite \underline{operazioni regolari}

\begin{enumerate}[itemsep=-7pt]
\item \underline{Unione}: $A{\cup}B{=}\{w\, |\, w{\in}A \vee  w{\in}B\}$
\item \underline{Concatenazione}: $A{\circ}B{=}\{wv\, |\, w{\in}A \wedge  v{\in}B\}$
\item \underline{Star}: $A^*{=}\{w_0w_1...w_k\, |\, w_i{\in}A \wedge 0{\leq}i{\leq}k\}$
\end{enumerate}
\end{definition}

### Equivalenza tra gli NFA e i DFA

> *Gli automi finiti deterministici e quelli non deterministici riconoscono la stessa classe di linguaggi.*

Questa affermazione appare sorprendente perchè gli $NFA$ sembrano avere maggior potere computazionale dei $DFA$, quindi sarebbe plausibile aspettarsi che i primi riconoscano più linguaggi dei secondi. Possiamo formalizzare con un teorema.

\begin{theorem}
Per ogni automa finito non deterministico, esiste un automa finito deterministico equivalente.
\begin{proof}
...
\end{proof}
\end{theorem}




[^7]: L'*arrow type* di una funzione è generato dal *type constructor* che giustappone i tipi primitivi di argomenti e risultato ottenendo il tipo composto della funzione (`f :: a -> b`).
[^8]: Come nella più comune biliografia $\mathcal{P}$ indica l'insieme delle parti e $\epsilon$ la stringa vuota, anche se in questo caso è più corretto riferirsi al carattere nullo.
[^9]: Qui c'è effettivamente un abuso di notazione: con il termine *macchina* mi riferisco ad un automa perchè queste proprietà sono valide anche per una MdT.
[^10]: Si può dimostrare (vedi Sipser cap.1) che la classe dei linguaggi regolari è chiusa rispetto alle tre operazioni regolari.
