# Automi e linguaggi \hfill \faCubes




## DFA e NFA

In questo capitolo verranno richiamate alcune nozioni utili per studiare *decidibilità*, *riducibilità* ed eventualmente l'insolubilità di problemi. Sarà utile avere ben chiaro cosa siano automi, linguaggi regolari e la loro relazione con le MdT.

\begin{definition}
Un \underline{automa finito determinastico} (DFA) è la quintupla
$$(Q, \Sigma, \delta, q_0, F)$$

\begin{itemize}[itemsep=-7pt]
\item $Q$ è l'insieme finito degli stati
\item $\Sigma$ è l'insieme finito dei simboli (alfabeto)
\item $\delta{:}Q{\times}\Sigma{\rightarrow}Q$ è la funzione di transizione
\item $q_0{\in}Q$ è lo stato iniziale
\item $F{\subseteq}Q$ è l'insieme degli stati di accettazione
\end{itemize}
\end{definition}

La funzione di transizione $\delta$ definisce le regole per il cambiamento di stato: specifica esattamente uno stato successivo per ogni possibile combinazione di stato e simbolo in input. Se ne deduce che, *da ogni stato esce esattamente un arco di transizione per ogni possibile simbolo di input* (ecco perchè automa determinastico o DFA).

\begin{definition}
Un \underline{automa finito non deterministico} (NFA) è la quintupla
$$(Q, \Sigma, \Delta, q_0, F)$$

\begin{itemize}[itemsep=-7pt]
\item $Q$ è l'insieme finito degli stati
\item $\Sigma$ è l'insieme finito dei simboli (alfabeto)
\item $\Delta{:}Q{\times}\Sigma_\epsilon{\rightarrow}\mathcal{P}(Q)$ è la funzione di transizione
\item $q_0{\in}Q$ è lo stato iniziale
\item $F{\subseteq}Q$ è l'insieme degli stati di accettazione
\end{itemize}
\end{definition}

Le due definizioni di automa differiscono nel tipo[^7] della funzione di transizione. $\Delta$ prende uno stato dall'insieme degli stati $Q$, un simbolo dall'alfabeto $\Sigma_\epsilon{=}\Sigma{+}\{\epsilon\}$ e produce l'insieme dei possibili stati successivi (${\subseteq}\mathcal{P}(Q)$); $\delta$ invece, prende in input la coppia stato attuale, simbolo letto e produce un singolo stato successivo[^8].




## Linguaggio della macchina[^9]

Automa o MdT, incomincia a essere chiaro che la nostra macchina sia qualcosa che mangia stringhe e decide se appartengono a un dato insieme.

* Esistono stringhe che una macchina $M$ non digerisce?
* Che succede quando una macchina $M$ prende in input una stringa $w$?
* Come distinguo gli insiemi di stringhe che la macchina elabora?

Per rispondere devo prima piazzare qualche paletto e senza perdere tempo in pesanti formalismi, ecco qua sotto alcune definizioni fondamentali.

\begin{definition}
Sia $M{=}\{Q,\Sigma,\delta,q_0,F\}$ un automa finito e $w{=}w_0w_1...w_n$ una stringa composta da caratteri $w_i{\in}\Sigma$. Si dice che la macchina $M$ \underline{accetta la stringa} $w$ se esiste una sequenza di stati $[r_0,r_1,...,r_{n+1}]$ in $Q$, con tre condizioni

\begin{enumerate}[itemsep=-7pt]
\item $r_0{=}q_0$: la macchina è partita e si trova in $q_0$
\item $\delta(r_i,w_{i+1}){=}r_{i+1}$, $0{\leq}i{\leq}n{-}1$: la macchina cambia stato con $\delta$
\item $r_n{\in}F$: la macchina accetta l'input se termina in un $q_F{\in}F$
\end{enumerate}
\end{definition}

Si noti l'assonanza con la definizione di computazione: i tre passi precedenti sono infatti da considerarsi i tre stadi della computazione per un automa finito. La macchina accetta l'input (quindi parte), salta di stato in stato con una legge predefinita (funzione di transizione) e dopo un numero indefinito (ma finito) di salti, casca in uno degli stati di terminazione.

\begin{definition}
Il \underline{linguaggio della macchina} $M$ è l'insieme $A$ di tutte le stringhe accettate dalla macchina: $A{=}L(M)$.
\end{definition}

\begin{definition}
La macchina $M$ \underline{riconosce il linguaggio} $A$ se $A {=} \{w\, |\, w{\in}A,\, M \text{accetta}\, w\}$.
\end{definition}

\begin{definition}
Un linguaggio è chiamato \underline{regolare} sse esiste un automa finito che lo riconosce.
\end{definition}

Dalle precedenti definizioni, posso già facilmente intuire qualche semplice implicazione, che però non dimostro per mancanza di spazio (prova per esercizio) \faMehO.
$$\boxed{A\ \text{è regolare}} \Leftrightarrow \boxed{\exists\ M\ \text{che riconosce}\ A} \Leftrightarrow \boxed{M\ \text{accetta tutte le stringhe di}\ A}$$

### Le operazioni regolari

Trattare i linguaggi regolari non è lo scopo di queste note ma, visto che li ho introdotti, è giusto spendere due parole su come manipolarne le stringhe.

[^7]: Il tipo di una funzione (*arrow type*) è generato dal costruttore di tipo che giustappone i tipi primitivi di argomenti e risultato ottenendo il tipo composto della funzione (`f :: a -> b`).
[^8]: Come nella più comune biliografia $\mathcal{P}$ indica l'insieme delle parti e $\epsilon$ la stringa vuota, anche se in questo caso è più corretto riferirsi al carattere nullo.
[^9]: Qui c'è effettivamente un abuso di notazione: con il termine *macchina* mi riferisco ad un automa perchè queste proprietà sono valide anche per una MdT.

